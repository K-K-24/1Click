# ai/ai_processor.py

import os
import requests
import json
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class AIProcessor:
    """Class to handle AI processing of DITA XML with OpenAI API"""
    
    def __init__(self, api_key=None, model="gpt-4o-mini"):
        """
        Initialize the AI processor with API key and model
        
        Args:
            api_key: OpenAI API key (if None, will use OPENAI_API_KEY env var)
            model: Model to use (default: gpt-4o-mini)
        """
        self.api_key = api_key or os.environ.get("OPENAI_API_KEY")
        if not self.api_key:
            raise ValueError("OpenAI API key not provided and not found in environment variables")
        
        self.model = model
        self.api_url = "https://api.openai.com/v1/chat/completions"
        self.headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.api_key}"
        }
    
    def process_xml_with_comment(self, xml_content, underlined_text, comment_data):
        """
        Process XML with comment using OpenAI API
        
        Args:
            xml_content: Full XML content as string
            underlined_text: The underlined text from the UI
            comment_text: The comment text from the UI
            
        Returns:
            tuple: (modified_xml, explanation)
        """
        prompt = self._construct_prompt(xml_content, underlined_text, comment_data)
        
        try:
            response = self._call_openai_api(prompt)
            modified_xml, explanation = self._parse_response(response)
            return modified_xml, explanation
        except Exception as e:
            logger.error(f"Error processing XML with AI: {e}")
            return None, str(e)
    
    def _construct_prompt(self, xml_content, underlined_text, comment_data):
        """
        Construct the prompt for the AI model with HTML-aware comment handling
        
        Args:
            xml_content: Full XML content
            underlined_text: The underlined text info
            comment_data: Dictionary containing 'text' and 'html' of the comment
        """
        # Extract text and html from comment_data
        comment_text = comment_data.get('text', '')
        comment_html = comment_data.get('html', '')
        return [
            {"role": "system", "content": """
You are a DITA XML content processing assistant. You will be provided with:
1. A DITA XML document
2. Text that was underlined/highlighted in the document
3. A comment that describes changes to make to that highlighted text, including both plain text and HTML versions

Your task is to:
1. Find the exact element(s) in the XML that contain or represent the underlined text
2. Understand the requested change from the comment
3. IMPORTANT: Check if the requested change has already been implemented in the document
4. Only make the appropriate modification to the XML if the change has NOT already been implemented
5. Return the complete modified XML document
             


Important DITA-specific considerations:
             
DITA ELEMENT KNOWLEDGE:
- Always use proper DITA semantic elements instead of generic ones:
  * For notes and similar information: Use <note> tags with appropriate @type attributes:
    - <note> (default) for regular notes
    - <note type="tip"> for helpful tips
    - <note type="caution"> for cautions
    - <note type="remember"> for remember notes
    - <note type="restriction"> for restriction notes
            
    CRITICAL: For note addition, unless explicitly mentioned as tip, remember, caution or 
    restriction, ALWAYS use the default note with NO type attribute.
             
  * For user interface elements: Use <uicontrol> for UI controls, buttons, menus
  * For user inputs: Use <userinput> for text users should enter
  * For code: Use <codeph> for inline code, <codeblock> for blocks
  * For variable names: Use <varname> tags
  * For file paths/names: Use <filepath> tags
  * For cross-references:
    - <xref> with @href for external links
    - <xref> with @keyref for internal references
  * For lists:
    - <ul>/<li> for unordered lists
    - <ol>/<li> for ordered lists
    - <sl>/<sli> for simple lists
    - <dl>/<dlentry> (with <dt> and <dd>) for definition lists
  * For tables, use <table> with proper <tgroup>, <thead>, <tbody>, <row>, and <entry> structure

CRITICAL: DO NOT add 'id' attributes to any elements you create. IDs are auto-generated by the system.

DUPLICATE DETECTION:
- When asked to add a note or other content, first check if similar content already exists
- If a note with similar content already exists in the location specified, do not add a duplicate note
- If the comment requests a change that's already been implemented, return the XML unchanged and explain that the change appears to already be in place

DISAMBIGUATION:
- If there are repeated instances of the same highlighted text in the document, use contextual clues to determine which instance should be modified. Pay attention to:
  * Surrounding elements and text mentioned in the comment
  * Element types and attributes that match the nature of the comment (e.g., URL changes likely apply to xref elements)
  * The location within the document structure (section, chapter, etc.)

DITA STRUCTURE:
- The underlined text might be split across multiple adjacent elements
- Text might not appear verbatim in the XML due to:
  * conkeyref attributes that pull content from elsewhere
  * pname elements with references
  * Text distributed across specialized elements (uicontrol, userinput, codeph, etc.)
- Handle DITA special attributes correctly (oxy_* attributes, -dita-use-conref-target values)
- Preserve all ID/IDREF relationships and don't break existing references

CHANGE TYPES:
- URL updates: For an href change in an xref element, modify only the href attribute, not the containing element
- Text replacement: Replace text while preserving the original element structure
- Element attribute changes: Modify attributes without changing element content
- Content restructuring: Carefully maintain the document hierarchy
- New content addition: When no underlined text is provided but comment describes new content to add, 
  analyze the comment and determine the best location to add the new content based on context

TECHNICAL REQUIREMENTS:
- Preserve ALL namespaces, including default namespaces
- Maintain exact whitespace formatting when possible
- Properly handle XML entities (&amp;, &lt;, etc.)
- Ensure all specialized attributes remain intact, including oxy_* attributes
- Preserve XML comments and processing instructions
"""
            },
            {"role": "user", "content": f"""
ORIGINAL XML:
{xml_content}

UNDERLINED TEXT:
{underlined_text}

COMMENT (plain text):
{comment_text}

COMMENT (HTML structure):
{comment_html}

Please provide ONLY the modified XML document with no additional explanation or markdown formatting.
"""
            }
        ]
    
    def _call_openai_api(self, messages):
        """Call OpenAI API with the given messages"""
        payload = {
            "model": self.model,
            "messages": messages,
            "temperature": 0.1,  # Low temperature for consistent output
        }
        
        try:
            response = requests.post(self.api_url, headers=self.headers, json=payload)
            response.raise_for_status()  # Raise exception for error status codes
            return response.json()
        except requests.RequestException as e:
            logger.error(f"API request failed: {e}")
            if hasattr(e, 'response') and e.response:
                logger.error(f"Response: {e.response.text}")
            raise
    
    def _parse_response(self, response):
        """Parse the response from OpenAI API"""
        try:
            content = response['choices'][0]['message']['content']
            
            # If the response contains an explanation, extract it
            if "```xml" in content and "```" in content:
                # Extract XML between code blocks
                xml_start = content.find("```xml")
                if xml_start == -1:
                    xml_start = content.find("```")
                xml_start = content.find("\n", xml_start) + 1
                xml_end = content.rfind("```")
                modified_xml = content[xml_start:xml_end].strip()
                
                # Extract explanation if present
                explanation_parts = content.split("```")
                if len(explanation_parts) > 2:
                    explanation = explanation_parts[-1].strip()
                else:
                    explanation = "XML modified successfully."
            else:
                # Assume the entire content is XML
                modified_xml = content.strip()
                explanation = "XML modified successfully."
            
            return modified_xml, explanation
        except (KeyError, IndexError) as e:
            logger.error(f"Error parsing API response: {e}")
            logger.error(f"Response content: {response}")
            raise ValueError(f"Invalid API response format: {e}")

# Helper function for easy integration with existing code
def process_dita_comment(xml_content, underlined_info, comment_data, api_key=None, model="gpt-4o-mini"):
    """
    Process a DITA comment using AI to modify the XML
    
    Args:
        xml_content: The full XML source
        underlined_info: Dictionary with information about the underlined text
        comment_text: The actual comment text
        api_key: OpenAI API key (optional)
        model: Model to use (default: gpt-4o-mini)
        
    Returns:
        tuple: (modified_xml, explanation)
    """
    processor = AIProcessor(api_key, model)
    
    # Extract visible text from underlined_info
    visible_text = underlined_info.get("visible_text", "")
    
    return processor.process_xml_with_comment(xml_content, visible_text, comment_data)